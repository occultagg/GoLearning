# 错误

go中的异常有三种级别：

- error：部分流程出错，需要处理
- panic：很严重的问题，程序应该再处理完问题后立即退出
- fetal：非常致命的问题，程序应该立即退出

> 准确的来说，Go并没有异常，更多的是通过错误来体现，同样的，Go中也并没有`try-catch-finally`这种语句，Go创始人希望能够将错误可控，以编程的方式来控制错误，他们不希望干什么事情都需要嵌套一堆`try-catch`，所以大多数情况会将其作为函数的返回值来返回

# error

error本身是一个预定义接口，接口下只有一个方法，该方法返回字符串，用于输出错误信息

```go
type error interface {
   Error() string
}
```

## 创建

## 自定义

## 传递

## 处理

- `errors.Unwrap()`函数用于解包一个错误链
- `errors.Is`函数的作用是判断错误链中是否包含指定的错误，所以在判断错误时，不应该使用`==`操作符，而是应该使用`errors.Is()`。
- `errors.As()`函数的作用是在错误链中寻找第一个类型匹配的错误，并将值赋值给传入的`err`。有些情况下需要将`error`类型的错误转换为具体的错误实现类型，以获得更详细的错误细节，而对一个错误链使用类型断言是无效的，因为原始错误是被结构体包裹起来的，这也是为什么需要`As`函数的原因。

# panic

> 表示十分严重的程序问题，程序需要立即停止来处理该问题，否则程序立即停止运行并输出堆栈信息，`panic`是Go是运行时异常的表达形式，通常在一些危险操作中会出现，主要是为了及时止损，从而避免造成更加严重的后果。不过`panic`在退出之前会做好程序的善后工作，同时`panic`也可以被恢复来保证程序继续运行。

## 创建

## 善后

## 恢复

# fatal

> 当发生`fatal`时，程序需要立刻停止运行，不会执行任何善后工作，通常情况下是调用`os`包下的`Exit`函数退出程序

fatal一般很少自己去触发。